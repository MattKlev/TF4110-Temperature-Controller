<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="MAIN" Id="{af87d6dd-0784-46eb-bd9b-ea6d96cfb9a1}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR		
		eCTRL_ModeController 	: E_CTRL_MODE := eCTRL_MODE_ACTIVE;
		eCTRL_ModeProcess	 	: E_CTRL_MODE := eCTRL_MODE_ACTIVE; 
		
		fW						: LREAL	:= 100.0;				(* setpoint *)
		fY						: LREAL;						(* control value *)
		fX						: LREAL;						(* actual value from simulated process *)
		
	
		stControllerParameter	: ST_CTRL_TempCtrlParameter := (		
		
			(* general parameters 													 *)
			iMode					:= 1,											(* 1=heating, 2=cooling, 3=heating&cooling *)
			iReactionOnFailure		:= eCTRL_ReactionOnFailure_StopController,		(* 0=controller off, 1=manual op, 2=yMin, 3=yMax *)
	    	
			bSelCtrlParameterSet	:= TRUE,										(* FALSE = internal set, TRUE = external set *)//Internal are calculated after an auto tune
	    	
			dwAlarmSupp				:= 16#0000EFFF,									(* alarm suppression *)
			tCtrlCycleTime			:= T#1MS,										(* controller cycle time *)
			tTaskCycleTime			:= T#1MS,										(* plc task cycle time *)
			
			(* tuning parameters 													 *)
			iTuningMode				:= 1,											(* only heating, only cooling, first heating then cooling or vice versa *)
	    	
			tTuneStabilisation		:= T#5S,										(* wait for a stable system *)
	    	
			fEndTunePercentHeating	:= 80.0,										(* switch to closed loop control when X > 0.8*W *)
			fYTuneHeating			:= 100.0,										(* step change while tuning operation *)
			fYStableHeating			:= 0.0,											(* tuning operation *)
	    	
			fEndTunePercentCooling	:= 20.0,										(* switch to closed loop control when X < 0.2*W *)
			fYTuneCooling			:= 0.0,											(* step change while tuning operation *)
			fYStableCooling			:= 0.0,											(* tuning operation *)
			fScalingFactor			:= 1.0,											(* Scaling factor for KP heating/cooling *)
			
			(* setpoint parameters 													 *)
			fWMin					:= 0.0,											(* lower limit *)
			fWMax					:= 300.0,										(* upper limit *)
	    	
			(* start up *)
			bEnableSoftStart		:= TRUE,										(* FALSE = no soft start, TRUE = soft start *)
			fWStartUp				:= 50.0,										(* soft start plateau setpoint *)
			tStartUp				:= T#10S,										(* soft start waiting time*)
			bStartUpRamping			:= TRUE,										(* enable ramping while start up phase *)
			fWStartUpVeloPos		:= 0.5,										(* max gradient for increasing setpoint in start up phase*)
			fWStartUpVeloNeg		:= 0.5,										(* max gradient for decreasing setpoint in start up phase *)
	    	
		
			bEnableRamping			:= TRUE,										(* FALSE = no ramping, TRUE = ramping *)
			fWVeloPos				:= 2.0,											(* max gradient for increasing setpoint *)
			fWVeloNeg				:= 2.0,											(* max gradient for decreasing setpoint *)	
	    	
			(* actual value parameters     											 *)
			bFilter 				:= FALSE,
			tFilter					:= T#0S,
			
			(* deadband parameters     												 *)
			bDeadband				:= FALSE,
			fEDeadband				:= 0.0,											(* deadband *)
			
			(* control value parameters     										 *)
			fYMin					:= 0.0,											(* lower limit *)
			fYMax					:= 100.0,										(* upper limit *)
			fYManual				:= 0.0,									 		(* manual operation*)
			fYOnFailure				:= 0.0,											(* control value on failure *)
	    	
			tPWMCycleTime			:= t#1s,										(* PWM: period *)
			tPWMMinOffTime			:= t#0s,										(* PWM: min off time *)
			tPWMMinOnTime			:= t#0s,										(* PWM: min on time *)
			tPWMWaitingTime			:= t#0s,										(* PWM: min waiting time *) (* not yet implemented !!!!*)
	    	
			fYThresholdOff			:= 0.0,											(* 3-Point: Off threshold *)
			fYThresholdOn			:= 0.0,											(* 3-Point: On threshold *)
	    	
			nCyclesForSwitchOver	:= 100,
	    	
			(* controller settings			     									 *)
			bEnablePreController 	:= FALSE,										(* enable precontroller *)
			bEnableZones 			:= FALSE,										(* enable zone around setpoint with open loop control *)
			bEnableCVFilter 		:= FALSE,										(* enable filter for CV (type see iFilterType) *)
			iFilterType 			:= E_CTRL_FilterType.eCTRL_FilterType_FIRSTORDER,(* filtertype of CV filter *)
			iControllerType 		:= eCTRL_ControllerType_PID,					(* used controller normally PID *)
			
			
			(* min max temperatures	     											 *)
			TempLow					:= -5.0,
			TempLowLow				:= -10.0,
			TempHigh				:= 5.0,
			TempHighHigh			:= 10.0,
			TempAbsoluteHigh		:= 300.0,
			TempAbsoluteLow			:= 0.0,	
			
			(* internal tuning parameters *)
			fTuneKp					:= 1.2,
			fTuneTn					:= 2.0,
			fTuneTv					:= 0.42,
			fTuneTd					:= 0.25
		);
	
		
	fbTempController			: FB_CTRL_TempController;
	
	fbProcess					: FB_Process;	
	stController				: ST_CTRL_ParaController := (KpHeat := 1.3058655833206456, TnHeat := TIME#1m13s730ms, TvHeat := TIME#15s483ms, TdHeat := TIME#3s871ms);
	
	
	bFirstTime					:BOOL:=TRUE;
	fSetpoint					:LREAL;
	
	bMakeSoftStartRampingWork	:BOOL:=TRUE;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[

(* Simulate process *)
fbProcess(	eCTRL_Mode	:= eCTRL_ModeProcess,
			fY 			:= fbTempController.fYAnalog, 
			bNoise 		:= , 
			tTa 		:= stControllerParameter.tTaskCycleTime);	

(* Actual temperature *)				
fX := fbProcess.fX;	

IF bMakeSoftStartRampingWork THEN
	//work around to make soft start ramping work
	//Credit Bill Wagner @ KNS
	IF (bFirstTime) THEN
	             fSetpoint := fX;                                                                      // set our new ramping start point to the current input
	             stControllerParameter.fWVeloPos 			:= 1_000_000_000.0;                          // make sure we ramp up in one cycle (temp override)
	             stControllerParameter.fWVeloNeg 			:= 1_000_000_000.0;                         // make sure we ramp down in one cycle (temp override)
	              
	             stControllerParameter.fWStartUp 			:= fX;
	             stControllerParameter.fWStartUpVeloPos 	:= 1_000_000_000.0; //Lower these to for example to 1. Then this work around will not work. 
	             stControllerParameter.fWStartUpVeloNeg 	:= 1_000_000_000.0; //Lower these to for example to 1. Then this work around will not work. 
				  bFirstTime:=FALSE; 
	ELSE
				stControllerParameter.fWVeloPos				:=2.0;
	            stControllerParameter.fWVeloNeg				:=2.0;
	
				
				stControllerParameter.fWStartUp 			:= 50.0;
				stControllerParameter.fWStartUpVeloPos 		:= 0.5;
				stControllerParameter.fWStartUpVeloNeg 		:= 0.5;
				
	            fSetpoint := fW;
	END_IF;
		
	
	IF (fbTempController.fbStartupTimer.Q) THEN                                                                                                                                                                          // 
	      stControllerParameter.bStartUpRamping := stControllerParameter.bEnableRamping;
	      stControllerParameter.fWStartUpVeloPos := stControllerParameter.fWVeloPos;
	END_IF;
	////
ELSE
	 fSetpoint := fW;
END_IF

(* Controller *)
fbTempController(
					eCtrlMode				:= eCTRL_ModeController, 
					bSelSetpoint			:= FALSE, 
                    fW1                     := fSetpoint,
                    fX                      := fX,                 
					fYManual				:= , 
					bOpenThermocouple		:= FALSE, 
					bReverseThermocouple	:= FALSE, 
					bBackVoltage			:= FALSE, 
					bLeakage				:= FALSE, 
					bShortCircuit			:= FALSE, 
					bOpenCircuit			:= FALSE, 
					sParaControllerExternal	:= stController, 
					sControllerParameter	:= stControllerParameter, 
					);
					 
(* Analog output *)			
fY 			:= fbTempController.fYAnalog;

]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>