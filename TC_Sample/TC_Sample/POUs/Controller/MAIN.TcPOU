<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="MAIN" Id="{af87d6dd-0784-46eb-bd9b-ea6d96cfb9a1}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
		xStart					: BOOL;
		
		eCTRL_ModeController 	: E_CTRL_MODE := eCTRL_MODE_IDLE;
		eCTRL_ModeProcess	 	: E_CTRL_MODE := eCTRL_MODE_IDLE; 
		
		fW						: LREAL	:= 100.0;				(* setpoint *)
		fY						: LREAL;						(* control value *)
		fX						: LREAL;						(* actual value from simulated process *)
		
	
		stControllerParameter	: ST_CTRL_TempCtrlParameter := (		
		
			(* general parameters 													 *)
			iMode					:= 1,											(* 1=heating, 2=cooling, 3=heating&cooling *)
			iReactionOnFailure		:= eCTRL_ReactionOnFailure_StopController,		(* 0=controller off, 1=manual op, 2=yMin, 3=yMax *)
	    	
			bSelCtrlParameterSet	:= TRUE,										(* FALSE = internal set, TRUE = external set *)//Internal are calculated after an auto tune
	    	
			dwAlarmSupp				:= 16#0000EFFF,									(* alarm suppression *)
			tCtrlCycleTime			:= T#1MS,										(* controller cycle time *)
			tTaskCycleTime			:= T#1MS,										(* plc task cycle time *)
			
			(* tuning parameters 													 *)
			iTuningMode				:= 1,											(* only heating, only cooling, first heating then cooling or vice versa *)
	    	
			tTuneStabilisation		:= T#5S,										(* wait for a stable system *)
	    	
			fEndTunePercentHeating	:= 80.0,										(* switch to closed loop control when X > 0.8*W *)
			fYTuneHeating			:= 100.0,										(* step change while tuning operation *)
			fYStableHeating			:= 0.0,											(* tuning operation *)
	    	
			fEndTunePercentCooling	:= 20.0,										(* switch to closed loop control when X < 0.2*W *)
			fYTuneCooling			:= 0.0,											(* step change while tuning operation *)
			fYStableCooling			:= 0.0,											(* tuning operation *)
			fScalingFactor			:= 1.0,											(* Scaling factor for KP heating/cooling *)
			
			(* setpoint parameters 													 *)
			fWMin					:= 0.0,											(* lower limit *)
			fWMax					:= 300.0,										(* upper limit *)
	    	
			(* start up *)
			bEnableSoftStart		:= TRUE,										(* FALSE = no soft start, TRUE = soft start *)
			fWStartUp				:= 50.0,										(* soft start plateau setpoint *)
			tStartUp				:= T#10S,										(* soft start waiting time*)
			bStartUpRamping			:= TRUE,										(* enable ramping while start up phase *)
			fWStartUpVeloPos		:= 1.0,										(* max gradient for increasing setpoint in start up phase*)
			fWStartUpVeloNeg		:= 1.0,										(* max gradient for decreasing setpoint in start up phase *)
	    	
		
			bEnableRamping			:= TRUE,										(* FALSE = no ramping, TRUE = ramping *)
			fWVeloPos				:= 10.0,											(* max gradient for increasing setpoint *)
			fWVeloNeg				:= 10.0,											(* max gradient for decreasing setpoint *)	
	    	
			(* actual value parameters     											 *)
			bFilter 				:= FALSE,
			tFilter					:= T#0S,
			
			(* deadband parameters     												 *)
			bDeadband				:= FALSE,
			fEDeadband				:= 0.0,											(* deadband *)
			
			(* control value parameters     										 *)
			fYMin					:= 0.0,											(* lower limit *)
			fYMax					:= 100.0,										(* upper limit *)
			fYManual				:= 0.0,									 		(* manual operation*)
			fYOnFailure				:= 0.0,											(* control value on failure *)
	    	
			tPWMCycleTime			:= t#1s,										(* PWM: period *)
			tPWMMinOffTime			:= t#0s,										(* PWM: min off time *)
			tPWMMinOnTime			:= t#0s,										(* PWM: min on time *)
			tPWMWaitingTime			:= t#0s,										(* PWM: min waiting time *) (* not yet implemented !!!!*)
	    	
			fYThresholdOff			:= 0.0,											(* 3-Point: Off threshold *)
			fYThresholdOn			:= 0.0,											(* 3-Point: On threshold *)
	    	
			nCyclesForSwitchOver	:= 100,
	    	
			(* controller settings			     									 *)
			bEnablePreController 	:= FALSE,										(* enable precontroller *)
			bEnableZones 			:= FALSE,										(* enable zone around setpoint with open loop control *)
			bEnableCVFilter 		:= FALSE,										(* enable filter for CV (type see iFilterType) *)
			iFilterType 			:= E_CTRL_FilterType.eCTRL_FilterType_FIRSTORDER,(* filtertype of CV filter *)
			iControllerType 		:= eCTRL_ControllerType_PID,					(* used controller normally PID *)
			
			
			(* min max temperatures	     											 *)
			TempLow					:= -5.0,
			TempLowLow				:= -10.0,
			TempHigh				:= 5.0,
			TempHighHigh			:= 10.0,
			TempAbsoluteHigh		:= 300.0,
			TempAbsoluteLow			:= 0.0,	
			
			(* internal tuning parameters *)
			fTuneKp					:= 1.2,
			fTuneTn					:= 2.0,
			fTuneTv					:= 0.42,
			fTuneTd					:= 0.25
		);
	
		
	fbTempController			: FB_CTRL_TempController;
	
	fbProcess					: FB_Process;	
	stController				: ST_CTRL_ParaController := (KpHeat := 1.3058655833206456, TnHeat := TIME#1m13s730ms, TvHeat := TIME#15s483ms, TdHeat := TIME#3s871ms);
	
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF xStart THEN
	xStart:=FALSE;
	eCTRL_ModeController	:=E_CTRL_MODE.eCTRL_MODE_ACTIVE;
	eCTRL_ModeProcess		:=E_CTRL_MODE.eCTRL_MODE_ACTIVE;
END_IF


(* Simulate process *)
fbProcess(	eCTRL_Mode	:= eCTRL_ModeProcess,
			fY 			:= fbTempController.fYAnalog, 
			bNoise 		:= , 
			tTa 		:= stControllerParameter.tTaskCycleTime);	

(* Actual temperature *)				
fX := fbProcess.fX;	

(* Controller *)
fbTempController(
					eCtrlMode				:= eCTRL_ModeController, 
					bSelSetpoint			:= FALSE, 
					fW1						:= fW, 
					fW2						:= , 
					fX						:= fX, 
					fYManual				:= , 
					bOpenThermocouple		:= FALSE, 
					bReverseThermocouple	:= FALSE, 
					bBackVoltage			:= FALSE, 
					bLeakage				:= FALSE, 
					bShortCircuit			:= FALSE, 
					bOpenCircuit			:= FALSE, 
					sParaControllerExternal	:= stController, 
					sControllerParameter	:= stControllerParameter, 
					);
					 
(* Analog output *)			
fY 			:= fbTempController.fYAnalog;

]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>